<!DOCTYPE html>

<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1">

		<!-- Begin Jekyll SEO tag v2.6.1 -->
<title>Search | SkyView</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="Search" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Projeto SkyView - P30 - ES 2021" />
<meta property="og:description" content="Projeto SkyView - P30 - ES 2021" />
<link rel="canonical" href="http://localhost:4000/search/" />
<meta property="og:url" content="http://localhost:4000/search/" />
<meta property="og:site_name" content="SkyView" />
<script type="application/ld+json">
{"@type":"WebPage","url":"http://localhost:4000/search/","publisher":{"@type":"Organization","logo":{"@type":"ImageObject","url":"http://localhost:4000/images/favicon.png"}},"headline":"Search","description":"Projeto SkyView - P30 - ES 2021","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

		<link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="SkyView" />

		<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Merriweather:400,400italic,700,700italic|Open+Sans:400,400italic,600,600italic,700,700italic|Inconsolata:400,700">
		<link rel="stylesheet" href="/css/main.css">
		<link rel="apple-touch-icon" href="/apple-touch-icon.png">
		<link rel="icon" type="image/png" href="/images/favicon.png">

		
	</head>

	<body>
		<header>
			<h1>
				<a href="/" style="display:table;">
					<span style="display:table-cell;vertical-align:middle;" class="back-arrow icon"><svg fill="#000000" height="24" width="24" xmlns="http://www.w3.org/2000/svg"><rect id="backgroundrect" width="100%" height="100%" x="0" y="0" fill="none" stroke="none"/>
  
  
<g class="currentLayer" style=""><title>Layer 1</title><path d="M0 0h24v24H0z" fill="none" id="svg_1"/><path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z" id="svg_2" class="selected" fill="#ffffff" fill-opacity="1"/></g></svg></span>
					<img style="display:table-cell;" src="/images/favicon.png" width="40" height="40" alt="SkyView logo">
				</a>
				SkyView
				<button type="button" class="open-nav" id="open-nav"></button>
			</h1>

			<form action="/search/" method="get">
				<input type="text" name="q" id="search-input" placeholder="Search" autofocus>
				<input type="submit" value="Search" style="display: none;">
			</form>

			<nav class="full-navigation">
				<ul>
					<li class="nav-item top-level ">
						
						<a href=""><b>Documentação</b></a>
					</li>
				</ul>

				
				
				
				<ul>
					
					
						<li class="nav-item top-level ">
							
							<a href="/docs/an%C3%A1lise/cenarios/">Análise</a>
							<ul>
								
									<li class="nav-item "><a href="/docs/an%C3%A1lise/cenarios/">Cenários</a></li>
								
							</ul>
						</li>
					
				</ul>
				
				
				
				<ul>
					
					
						<li class="nav-item top-level ">
							
							<a href="/docs/desenvolvimento/arquitetura/">Desenvolvimento</a>
							<ul>
								
									<li class="nav-item "><a href="/docs/desenvolvimento/arquitetura/">Arquitetura</a></li>
								
									<li class="nav-item "><a href="/docs/desenvolvimento/consumers/">Consumers</a></li>
								
									<li class="nav-item "><a href="/docs/desenvolvimento/producers/">Producers</a></li>
								
							</ul>
						</li>
					
						<li class="nav-item top-level ">
							
							<a href="/docs/desenvolvimento/jenkins/">Especificação</a>
							<ul>
								
									<li class="nav-item "><a href="/docs/desenvolvimento/jenkins/">Jenkins</a></li>
								
							</ul>
						</li>
					
						<li class="nav-item top-level ">
							
							<a href="/docs/desenvolvimento/deployment/">Operações</a>
							<ul>
								
									<li class="nav-item "><a href="/docs/desenvolvimento/deployment/">Deployment</a></li>
								
									<li class="nav-item "><a href="/docs/desenvolvimento/monitoring/">Logging agregado</a></li>
								
							</ul>
						</li>
					
				</ul>
				
				
				
				<ul>
					
					
						<li class="nav-item top-level ">
							
							<a href="/docs/frontend/manual/">Frontend</a>
							<ul>
								
									<li class="nav-item "><a href="/docs/frontend/manual/">Manual do Utilizador</a></li>
								
									<li class="nav-item "><a href="/docs/frontend/programador/">Perspetiva do Programador</a></li>
								
							</ul>
						</li>
					
				</ul>
				
				
				
				<ul>
					
					
						<li class="nav-item top-level ">
							
							<a href="/docs/desenvolvimento/testes/">Operações</a>
							<ul>
								
									<li class="nav-item "><a href="/docs/desenvolvimento/testes/">Testes</a></li>
								
									<li class="nav-item "><a href="/docs/desenvolvimento/TICK/">Métricas</a></li>
								
							</ul>
						</li>
					
				</ul>
				
				

				
				
				
				
				
				
				
				
				
				
			</nav>
		</header>

		<section class="main">
			<div class="page-header">
				<h2>SkyView</h2>
				<h3>Search</h3>
			</div>
			<article class="content">
				<p><span id="search-process">Loading</span> results <span id="search-query-container" style="display: none;">for "<strong id="search-query"></strong>"</span></p>
<ul id="search-results"></ul>

<script>
	window.data = {
		
			
				
					
					

					"docs-an-c3-a1lise-cenarios": {
						"id": "docs-an-c3-a1lise-cenarios",
						"title": "Cenários",
						"category": "",
						"url": " /docs/an%C3%A1lise/cenarios/",
						"content": "O utilizador observa os voos que sobrevoam a Alemanha em tempo real e escolhe o modo de visualização dos voos que estão prestes a aterrar. Encontrado o voo que procura, interage com o mesmo e observa os gráficos relativos a este (velocidade, altitude), bem como a rota do avião.\n  \n  \n    O utilizador consulta estatísticas gerais sobre os voos já terminados, observando as rotas mais comuns na Alemanha e o número de aterragens efetuadas em cada aeroporto da mesma.\n  \n  \n    O utilizador observa os índices de poluição nos aeroportos da Alemanha em tempo real. Ao interagir com um aeroporto, o utilizador visualiza o histórico de aterragens nesse mesmo aeroporto, bem como um gráfico correlacionando o número de aterragens com o índice de poluição.\n  \n  \n    O utilizador recebe uma notificação relativa à ocorrência de eventos na SkyView, tais como o aparecimento de um voo na Alemanha ou a aterragem de um avião num dos aeroportos alemães."
					}

					
				
			
		
			
				
					,
					

					"docs-desenvolvimento-tick": {
						"id": "docs-desenvolvimento-tick",
						"title": "Métricas",
						"category": "",
						"url": " /docs/desenvolvimento/TICK/",
						"content": "Em termos da obtenção periódica e persistência centralizada de valores de métricas de estado atual e desempenho dos diversos componentes e micro-serviços foi utilizado a TICK stack, dada a sua abertura, expansibilidade e facilidade de integração e de utilização.\nA instanciação e interligação dos seus componentes constituintes (Telegraf, InfluxDB, Chronograf, e Kapacitor) é assegurada através do uso de Docker-Compose.\n\n\n\nA recolha de métricas é efetuada periodicamente de cada um dos consumers desenvolvidos, através da integração nativa Quarkus Micrometer.\nDesta forma, são automaticamente incluídos diversos data points acerca do estado atual e desempenho da JVM, do módulo de integração com o Kafka (consumer e producer), e do módulo RESTEasy, bem como as métricas customizadas desenvolvidas pela equipa no próprio código fonte.\n\nEstas incluem contadores de número de pedidos REST recebidos, tamanho das listas de vôos/aeroportos recebidos dos tópicos Kafka, número de inserções no InfluxDB, número de eventos gerados, entre outros.\n\nA visualização do estado atual dos vários componentes do sistema at-a-glance é possibilitada por um dashboard Cronograf criado para o efeito, e que inclui um conjunto não exaustivo de métricas cruciais.\n\n\n\n\n  System CPU Usage\n  System Load Average\n  System Memory Usage\n  Events generated per 10 seconds (‘events’ kafka topic)\n  InfluxDB write operations executed per 10 seconds\n  Kafka messages consumed per 10 seconds\n  Kafka messages produced per 10 seconds\n  /stream SSE requests per 10 seconds\n  /all REST requests per 10 seconds\n  OpenWeather API response list size\n  OpenFlight API response list size"
					}

					
				
			
		
			
				
					,
					

					"docs-desenvolvimento-arquitetura": {
						"id": "docs-desenvolvimento-arquitetura",
						"title": "Arquitetura",
						"category": "",
						"url": " /docs/desenvolvimento/arquitetura/",
						"content": ""
					}

					
				
			
		
			
				
					,
					

					"docs-desenvolvimento-consumers": {
						"id": "docs-desenvolvimento-consumers",
						"title": "Consumers",
						"category": "",
						"url": " /docs/desenvolvimento/consumers/",
						"content": "Os módulos consumer constituem uma parte integral da arquitetura desenvolvida, visto que desempenham as seguintes funções:\n\n\n  Consumir dados provenientes dos tópicos Kafka populados pelos producers associados às APIs OpenSky e OpenWeather\n  Aplicar filtros, transformações, e outras operações aos mesmos\n  Ler e Escrever a informação relevante numa base de dados time-series InfluxDB (utilizando Flux)\n  Produzir dados processados e eventos para tópicos de Kafka\n  Servir atualizações em real-time para clientes de front-end através do uso de Server Sent Events (com interligação por Reactive Messaging)\n  Disponibilizar endpoints REST para obtenção de dados históricos em massa.\n\n\n\n\nFlights-Consumer\n\nA sua função é consumir os dados do endpoint /states da OpenSky API que são disponibilizados no tópico Kakfa ‘flights’ pelo producer correspondente.\n\nEstes são persistidos no InfluxDB (utilizando o InfluxDBClient) e enviados como Server Sent Events para o frontend e quaisquer outros clientes SSE conectados.\n\nAdicionalmente, os dados históricos são disponibilizados pelo endpoint REST /all, que recebe o Query Parameter ‘icao24’ como filtro e interage com o InfluxDB utilizando Flux para obter os dados.\n\nExemplo de payload JSON retornada pelo endpoint /all (com filtro por, neste caso, o icao24 ‘34310d’):\n{\n  \"time\": 1625023000,\n  \"states\": [\n    {\n      \"icao24\": \"34310d\",\n      \"callsign\": \"BCS3844 \",\n      \"originCountry\": \"Spain\",\n      \"timePosition\": \"2021-06-30T04:16:39\",\n      \"lastContact\": 1625022999,\n      \"longitude\": 12.2542,\n      \"latitude\": 51.4113,\n      \"baroAltitude\": 0,\n      \"onGround\": true,\n      \"velocity\": 3.86,\n      \"trueTrack\": 84.38,\n      \"verticalRate\": 0,\n      \"sensors\": \"\",\n      \"geoAltitude\": 0,\n      \"squawk\": \"\",\n      \"spi\": false,\n      \"positionSource\": 0\n    },\n    {\n      ...\n    }\n  ]\n}\n\n\nArrivals-Consumer\n\nA sua função é consumir os dados do endpoint /flights da OpenSky API que são disponibilizados no tópico Kakfa ‘arrivals’ pelo producer correspondente.\n\nEstes são enviados como Server Sent Events para o frontend e quaisquer outros clientes SSE conectados.\n\nExemplo de payload JSON retornada pelo endpoint SSE /stream:\n{\n  \"voos\": [\n    {\n      \"icao24\": \"3cce6f\",\n      \"firstSeen\": 1560980170,\n      \"estDepartureAirport\": \"EDDS\",\n      \"lastSeen\": 1560981639,\n      \"estArrivalAirport\": \"Stuttgart\",\n      \"callsign\": \"FCK211  \",\n      \"estDepartureAirportHorizDistance\": 353,\n      \"estDepartureAirportVertDistance\": 7,\n      \"estArrivalAirportHorizDistance\": 1051,\n      \"estArrivalAirportVertDistance\": 7,\n      \"departureAirportCandidatesCount\": 0,\n      \"arrivalAirportCandidatesCount\": 7\n    },\n    {\n      ...\n    }\n  ]\n}\n\n\nEnvironment-Consumer\n\nA sua função é consumir os dados da OpenWeather API que são disponibilizados no tópico Kakfa ‘environment’ pelo producer correspondente.\n\nEstes são persistidos no InfluxDB (utilizando o InfluxDBClient) e enviados como Server Sent Events para o frontend e quaisquer outros clientes SSE conectados.\n\nAdicionalmente, os dados históricos são disponibilizados pelo endpoint REST /all, que recebe o Query Parameter ‘icao’ como filtro e interage com o InfluxDB utilizando Flux para obter os dados.\n\nExemplo de payload JSON retornada pelo endpoint /all (com filtro por, neste caso, o icao ‘34310d’):\n[\n  {\n    \"name\": \"Berlin-Schönefeld\",\n    \"icao\": \"EDDB\",\n    \"time\": {\n      \"seconds\": 1625025577,\n      \"nanos\": 55186000\n    },\n    \"latitude\": 52.3738,\n    \"longitude\": 13.519,\n    \"aqi\": 1,\n    \"co\": 211.95,\n    \"no\": 0.01,\n    \"no2\": 12.51,\n    \"o3\": 49.35,\n    \"so2\": 4.77,\n    \"pm10\": 5.2,\n    \"nh3\": 0.74\n  },\n  {\n    ... \n  }\n]\n\n\nArrived-Consumer\n\nA secção ‘Producers’ contém os detalhes sobre a função desempenhada por este componente."
					}

					
				
			
		
			
				
					,
					

					"docs-desenvolvimento-deployment": {
						"id": "docs-desenvolvimento-deployment",
						"title": "Deployment",
						"category": "",
						"url": " /docs/desenvolvimento/deployment/",
						"content": "Arquitetura geral\n\nO ambiente de execução e instalação integrado neste projeto assume um padrão de micro-serviços envolvidos em containers, com recurso à ferramenta Docker, e ainda necessita de suporte para a ferramenta opcional docker-compose, acedidas por modo não-privilegiado.\n\nA arquitetura é explicada pelo diagrama abaixo. A rede de containers para o efeito é denominada subnet-proj, e corresponde à gama de endereços 172.29.0.0/24. Todos os containers deste projeto situar-se-ão nesta rede Docker.\n\n\n\nÉ utilizado um ficheiro docker-compose.yaml por forma a realizar o setup completo de todos os serviços. A arquitetura de instalação providenciada explica o próprio modelo de instalação que segue entre módulos.\n\nOutros requisitos\n\nEm termos de requisitos especiais, a máquina remota deve estar configurada com o ficheiro-parâmetro de sistema Linux vm.max_map_count com o valor mínimo de 262144, devido a ser um requerimento do Elasticsearch na versão 7.13.x .\n\nLocalização\n\nDe notar que todos os serviços do projeto serão instalados na mesma máquina, incluindo bases de dados, brokers e ferramentas de monitorização, logging e visualização. Isto significa que, no âmbito deste projeto, não são utilizadas as máquinas virtuais fornecidas para instalação do produto e acesso aos recursos de dados (partilhados) para as dependências do software desenvolvido – isto deve-se ao facto de não ter sido possível fazer a instalação da playground VM disponibilizada para o efeito. Como esta ficou sem recursos disponíveis para todos os projetos rapidamente, o mesmo tipo de problema poderia ter acontecido com a runtime VM, então optou-se por um ambiente gerido pelo grupo, na qual estivesse acedido pela Web (skyview.rrosmaninho.com)."
					}

					
				
			
		
			
				
					,
					

					"docs-desenvolvimento-jenkins": {
						"id": "docs-desenvolvimento-jenkins",
						"title": "Jenkins",
						"category": "",
						"url": " /docs/desenvolvimento/jenkins/",
						"content": "Overview\n\nNo que toca a pipeline Jenkins disponibilizada, esta permite que o produto corrente seja sempre continuamente e automaticamente atualizado, e sequencialmente pronto a ser utilizado, garantindo que o software da versão estável mais recente esteja sempre disponível e funcional no ambiente de execução cliente. No que toca ao seu desenho geral, foi delineada uma pipeline standard, que segue o modelo geral build-test-package-deploy.\n\n\n\nA configuração completa da pipeline não é apenas contemplada no código: na configuração desta pipeline no ambiente Jenkins a trabalhar, deve ser introduzido para usar o Jenkinsfile disponibilizado, e ainda deve ser dado corretamente o repositório na qual se encontra este projeto, de forma de haver um checkout implícito ao SCM antes de operacionalizar o workflow dado. Para isto, de notar que também é necessário configurar credenciais para o acesso ao repositório SCM pretendido.\n\nFases da pipeline\n\nAs fases de execução da presente pipeline são as seguintes:\n\n\n  \n    Build Java 8 – Faz a assemblagem de cada módulo Java 8, utilizando o Maven. Os testes não podem ser executados nesta fase, pois serão realizados numa fase posterior. Devido a haver seis módulos independentes Java no nosso projeto, e sendo que era desejado que o código da pipeline fosse o mais curto possível e o mais programático possível (no caso da quantidade de módulos aumentasse no futuro, e assim ser mais rápido de integrar um novo módulo em todas o ciclo de vida da pipeline), usou-se uma script que passa por uma lista de nomes de diretórios presentes no projeto, com o código de cada módulo, na qual executa a diretiva “install” do Maven, com a propriedade “skipTests”.\n  \n  \n    Build Java 11 – Similarmente à fase anterior, é feito o build de cada módulo Java, neste caso com a versão 11. Embora faça parte do mesmo contexto do que seria normalmente uma fase, é necessária esta divisão devido à diretiva para utilização do Java 11 nesta fase. Esta maneira foi a mais fácil de ser integrada na pipeline.\n  \n  \n    Test Java 8 – Esta fase trata de executar todos os testes de integração ou unitários em todos os módulos Java do software. Também é executado de forma programática e sequencial para cada aplicação Java 8, portanto detém o mesmo fluxo é feito para as fases anteriores. A diretiva de lifecycle Maven é a utilizada para utilizar todos os testes, que é o “test”.\n  \n  Test Java 11 – Com semelhanças às fases de build explicitadas anteriormente, este usa também a diretiva “tools” com a configuração da versão de SDK para Java 11. Esta fase, tal como a anterior, faz sequencialmente os testes aos módulos Java dos diretórios dos micro-serviços Java 11, incluídos em cada um destes (./src/test/*).\n    tools {\n  jdk \"jdk11\"\n}\n    \n  \n  \n    Upload artifacts – Após as fases lógicas de build e teste, esta fase assegura que os artefactos resultantes da assemblagem dos pacotes de software (JAR/WAR) da versão correspondente, seja armazenado num repositório de artefactos JFrog. Neste caso, o repositório é o oficial da disciplina, em http://192.168.160.49:8081/artifactory/maven_es2021. Isto é configurado no pom.xml e no settings.xml, e é usado apenas para o upload destes artefactos. Esta fase é transparente à versão do Java utilizada.\n  \n  \n    Push images – Esta fase realiza o build das imagens Docker e, consequentemente, o upload das imagens resultantes para o Docker Registry, que vai ser utilizado pela máquina de instalação do produto como a fonte de imagens no docker-compose de instalação. Neste caso, o repositório utilizado é, também, o oficial, localizado em http://192.168.160.48:5000. Esta fase faz o build a partir dos Dockerfiles localizados em cada módulo, e upload sequencial (push) para cada módulo do projeto. A fase inclui todos os componentes, incluindo a aplicação Node/ReactJS.\n  \n  Deploy – Esta fase acede à máquina de instalação para a entrega do pacote de software, mediante credenciais. Nesta versão final do projeto, a instalação de todos os serviços é feita numa máquina gerida pelo grupo, acedida em skyview.rrosmaninho.com, no porto 443, usando credenciais configuradas com um utilizador dependente (‘jenkins’) para o efeito. \nEsta fase acede primeiramente à máquina e limpa a instalação anterior, removendo todos os seus componentes. De seguida, remove ficheiros dependentes, como o manisfest YAML de instalação automática dos variados serviços (docker-compose.yml), assim como ficheiros de configuração de alguns serviços, necessários para o seu correto funcionamento. Depois, são novamente copiados para a mesma máquina o manifest e os ficheiros de configuração atualizados. Por fim, faz a execução do YAML sobre o Docker daemon (a partir do docker-compose up).\n\n\nAlterações posteriores\n\nNo caso de a máquina remota poder ser diferente ou na eventualidade da sua migração para outra localização, a definições dos campos da variável global “remote” devem ser atualizados: o “host” e o “port”. O campo “name” também pode ser mudado, no entanto não é fundamental para o funcionamento dos acessos SSH, servindo apenas para fazer a identificação posterior.\n\nEsta máquina destino para a instalação e entrega do produto deve ter um Docker deamon preparado com execução de comandos em modo non-root. Quaisquer certificados essenciais para o acesso ao Docker Registry devem ser instalados na máquina (certificados cliente em /etc/docker/certs; no caso de haver um certificado de CA Root independente, é ainda necessário instalá-lo no seu sistema Linux; no entanto, se for um ficheiro em formato PEM com a cadeia de certificação, é apenas necessário coloca-lo no diretório dito primeiramente).\n\nNo caso de possuir um registry Docker privado, é possível mudá-lo facilmente no código da pipeline, sendo que pode ser alterado na variável de ambiente REGISTRYHOST existente. Assim, o push e pull das imagens Docker na fase de Upload images poderá ser feito de outro Registry facilmente que não o por defeito neste projeto. É necessário, no entanto, que este esteja acessível tanto da máquina target, como na ferramenta Jenkins que vai ser utilizada."
					}

					
				
			
		
			
				
					,
					

					"docs-desenvolvimento-monitoring": {
						"id": "docs-desenvolvimento-monitoring",
						"title": "Logging agregado",
						"category": "",
						"url": " /docs/desenvolvimento/monitoring/",
						"content": "Overview\n\nA monitorização centralizada aos registos de logging gerados pelas aplicações é feita a partir da instalação e configuração de uma stack EFK (Elasticsearch, Fluentd, Kibana). Embora o Logstash seja o agregador de registos de logging mais utilizado, este modelo tem a particularidade de utilizar o Fluentd na sua vez, sendo que a sua configuração de cada fonte de dados é mais direta, e o formato de configuração é mais visualizável dentro do ficheiro.\n\nA monitorização de logging é necessária para se observar simultaneamente um número elevado de aplicações Java, que estão constantemente a produzir logs a um rácio significativo, por exemplo, significando que poderá existir ali um problema com o micro-serviço, como um número muito elevado de exceções runtime no código Java, o que pode revelar um problema com o código ou de comunicação entre os vários serviços que este depende. Mais ainda, a visualização de logs a partir de um ponto central permite maior reação à ocorrência de problema, sendo que os logs de vários serviços podem ser visualizados ao mesmo tempo, ou com filtros a partir de botões na interface da dashboard. O armazenamento destes registos permite a recolha de informação histórica do funcionamento da aplicação, necessária para, por exemplo, auditorias.\n\nStack\n\nA stack é fornecida dentro do pacote de software do projeto, a partir da instalação docker-compose. Estes componentes ligam-se naturalmente entre si, não precisando de grandes configurações, sendo que estão dentro de containers e as configurações mínimas já estão garantidas.\n\n\n\nO modelo de agregação de logs ilustra que os vários componentes de software Java enviam os seus logs para o agregador Fluentd no formato Syslog, que expõe um porto e recebe os vários registos sob a forma de mensagens, enviando depois estes registos recebidos para o serviço Elasticsearch. Esta abordagem é muito simples de implementar, no entanto pode sofrer de bottleneck em termos de performance e prontidão do envio das mensagens para o Elasticsearch em “tempo real”, pois com a escalabilidade do número de serviços existentes a monitorizar, poderá fazer com que um container de Fluentd não seja suficiente para o efeito; assim como poderá resultar em perda de registos de logging, devido ao protocolo UDP que é utilizado na transmissão de logs entre as aplicações e o agregador.\n\nIntegração ao software\n\nAs aplicações Quarkus são configuradas para enviar os seus logs a partir da configuração de parâmetros nos ficheiros “application.properties” correspondentes. A integração com a stack EFK com Quarkus é, então, trivial, superiorizando-se a aplicações com base em Spring Boot, que requerem a criação de appenders.\n\n\n\nVisualização de logs\n\nA ferramenta de visualização escolhida é o Kibana, pois está naturalmente integrada como parte da stack de logs centralizados, sendo que a visualização de logs e suas estatísticas base são facilmente criadas em painéis, e consequentemente dashboards.\n\nA dashboard de visualização realizada serve para ter o mínimo de informação prontamente disponível que se achou útil: em primeiro, uma tabela que mostra todos os registos de todos os logs da infraestrtura mediante o intervalo de tempo filtrado, que inclui, para além da mensagem os campos do nome dos serviços (ou seja, das aplicações) e o timestamp da sua ocorrência; depois, existe ainda um gráfico de barras da contagem de logs totais, nas últimas doze horas. Por fim, existe um painel de visualização de proporção de logs de cada aplicação a partir do tamanho da letra (quanto maior a letra em relação aos outros nomes, mais logs está a produzir comparativamente).\n\nEstes painéis, combinado com os filtros que estão integrados nas páginas das dashboards, permite rapidamente flitrar por aplicação ou aplicações, limitar intervalos de tempo para visualização, entre outros. Assim, a monitorização de logging atinge o nível de controlo desejado."
					}

					
				
			
		
			
				
					,
					

					"docs-desenvolvimento-producers": {
						"id": "docs-desenvolvimento-producers",
						"title": "Producers",
						"category": "",
						"url": " /docs/desenvolvimento/producers/",
						"content": "Flights Producer\n\nFlights-producer foi feito com SpringBoot e utiliza a API OpenSky, fazendo duas calls distintas e produzindo informação para dois topics diferentes: flights e arrivals.\n\nflights\nPara o preenchimento do topic flights é sempre feita a seguinte chamada:\n\nhttps://opensky-network.org/api/states/all?lamin=47.2&amp;lomin=5.5&amp;lamax=55.1&amp;lomax=15.5\n\n\nO resultado tem todos os voos cuja latitude e longitude estão delimitados pelos limites da Alemanha, obtendo assim todos os voos que estão atualmente a sobrevoar a área definida. Este resultado é guardado na classe FlightsState.\n\nA mensagem é enviada para o topic em formato json através do método gson.toJson().\n\nExemplo:\n{\n  \"time\": 1625017570,\n  \"states\": [\n    [\n      \"4bc847\",\n      \"PGT33P  \",\n      \"Turkey\",\n      1625017569,\n      1625017570,\n      11.2141,\n      49.8804,\n      10675.62,\n      false,\n      212.37,\n      117.25,\n      0,\n      null,\n      10949.94,\n      \"6426\",\n      false,\n      0\n    ],\n    ...\n}\n\n\narrivals\nPara o preenchimento do topic arrivals é sempre feita a seguinte chamada (com begin e end sendo limites temporais em epoch):\n\n\"https://opensky-network.org/api/flights/all?begin=\"+begin+\"&amp;end=\"+end\n\n\nO resultado tem a lista de todos os voos que estão/estavam ativos (no ar) no limite de tempo definido. Este resultado é guardado na classe Flights e depois filtrado para apenas sobrar os voos cujo parametro estArrivalAirport tenha um código ICAO de um aeroporto alemão. Este parametro é depois alterado para o nome do aeroporto através de um dicionário que relaciona os valores ICAO com os nomes reais.\n\nA mensagem é depois enviada para o topic em formato json através do método gson.toJson().\n\nExemplo:\n[\n  {\n    \"icao24\": \"48548c\",\n    \"firstSeen\": 1558953893,\n    \"estDepartureAirport\": \"EHAM\",\n    \"lastSeen\": 1558957226,\n    \"estArrivalAirport\": \"Stuttgart\",\n    \"callsign\": \"KLM1873\",\n    \"estDepartureAirportHorizDistance\": 1217,\n    \"estDepartureAirportVertDistance\": 94,\n    \"estArrivalAirportHorizDistance\": 1086.0,\n    \"estArrivalAirportVertDistance\": 14.0,\n    \"departureAirportCandidatesCount\": 0,\n    \"arrivalAirportCandidatesCount\": 5\n  },\n  ...\n]\n\n\nArrived Producer (and Consumer)\nArrived-producer foi feito com Quarkus e consome os dados do topic arrivals, produzidos pelo producer anterior, processando-os para depois produzir informação para dois topics diferentes: arrived e events.\n\nEm termos de processamento é utilizada a lógica de guardar sempre a última lista de voos recebida do topic arrivals, para quando consumir uma lista nova, poder comparar e verificar se há alguns voos novos ou se houve algum voo que desapareceu da lista.\n\nEstas listas são de facto objectos da classe Flights, obtidas através do método gson.fromJson() que recebe o json consumido.\n\narrived\nÉ produzido para o topic arrived quando se verifica que houve algum voo (classe Flight) que desapareceu da lista (classe Flights que contem uma lista de Flight).\n\nAssim, é produzida para o topic uma mensagem individual para cada Flight que se deteta que aterrou, utilizando o método gson.toJson().\n\nExemplo:\n\n{\n    \"icao24\": \"48548c\",\n    \"firstSeen\": 1558953893,\n    \"estDepartureAirport\": \"EHAM\",\n    \"lastSeen\": 1558957226,\n    \"estArrivalAirport\": \"Stuttgart\",\n    \"callsign\": \"KLM1873\",\n    \"estDepartureAirportHorizDistance\": 1217,\n    \"estDepartureAirportVertDistance\": 94,\n    \"estArrivalAirportHorizDistance\": 1086.0,\n    \"estArrivalAirportVertDistance\": 14.0,\n    \"departureAirportCandidatesCount\": 0,\n    \"arrivalAirportCandidatesCount\": 5\n}\n\n\nevents\nÉ produzido para o topic events quando se verifica que apareceu ou desapareceu um voo da lista, com mensagens distintas para cada um.\n\nExemplo de uma mensagem produzida quando aparece um novo voo na lista:\n\n    New flight '48548c' approaching Stuttgart airport at 1086.0 meters.\n\n\nExemplo de uma mensagem produzida quando desaparece um voo da lista:\n\n    Flight with id '48548c' arrived in Stuttgart airport.\n\n\nEnvironment Producer\n\nenvironment\nEnvironment-producer utiliza a API OpenWeatherMap, fazendo dezassete calls distintas e produzindo informação para o topic environment.\n\nPrimeiramente fomos pesquisar os valores de latitude e longitude para os 17 aeroportos mais frequentados na Alemanha obtendo a seguinte tabela, sendo estes os códigos ICAO que também sobram da filtragem no flights-producer.\n\n\n  \n    \n      ICAO\n      LAT\n      LON\n    \n  \n  \n    \n      EDDB\n      52.37\n      13.51\n    \n    \n      EDDT\n      52.55\n      13.28\n    \n    \n      EDDW\n      53.04\n      8.78\n    \n    \n      EDDK\n      50.85\n      7.13\n    \n    \n      EDLW\n      51.51\n      7.61\n    \n    \n      EDDC\n      51.13\n      13.76\n    \n    \n      EDDL\n      51.28\n      6.76\n    \n    \n      EDDF\n      50.03\n      8.57\n    \n    \n      EDDH\n      53.62\n      9.98\n    \n    \n      EDDV\n      52.46\n      9.68\n    \n    \n      EDSB\n      48.77\n      8.08\n    \n    \n      EDDP\n      51.42\n      12.23\n    \n    \n      EDDM\n      48.35\n      11.77\n    \n    \n      EDDG\n      52.13\n      7.68\n    \n    \n      EDDN\n      49.46\n      11.06\n    \n    \n      ETAR\n      49.43\n      7.60\n    \n    \n      EDDS\n      48.68\n      9.21\n    \n  \n\n\nPara obter o index de poluição para cada aeroporto realizamos a seguinte chamada, fornecendo a latitude e longitude previamente guardada:\n\nhttp://api.openweathermap.org/data/2.5/air_pollution?lat=\"+lat[i]+\"&amp;lon=\"+lon[i]+\"&amp;appid=\"+apikey;\n\n\nExemplo de um resultado da chamada:\n\n{\n  \"coord\": {\n    \"lon\": 13.51,\n    \"lat\": 52.37\n  },\n  \"list\": [\n    {\n      \"main\": {\n        \"aqi\": 1\n      },\n      \"components\": {\n        \"co\": 203.61,\n        \"no\": 0,\n        \"no2\": 10.2,\n        \"o3\": 52.93,\n        \"so2\": 3.93,\n        \"pm2_5\": 4.59,\n        \"pm10\": 4.96,\n        \"nh3\": 0.65\n      },\n      \"dt\": 1625022000\n    }\n  ]\n}\n\n\nEste resultado é guardado na classe ComponentsClass, e depois é enviado como argumento para o construtor da classe ComponentsByAirport que também recebe o código ICAO e o nome do aeroporto.\n\nNo fim de todas as chamadas, estes 17 objectos ComponentsByAirport são guardados numa lista de ComponentsByAirport, definida pela classe ComponentsGermany, que desta forma agrupa todos os dados de poluição de todos os aeroportos pretendidos.\n\nAssim, é produzida para o topic uma mensagem em formato json utilizando o método gson.toJson().\n\nExemplo:\n\n{\n    \"airports\":[\n        {\n            \"airporticao\":\"EDDB\",\n            \"airportname\":\"Berlin-Schönefeld\",\n            \"airportcomponents\":\n                {\"coord\":\n                    {\n                        \"lon\":13.519,\n                        \"lat\":52.3738\n                    },\n                    \"list\":[\n                        {\n                            \"main\":\n                            {\n                                \"aqi\":1\n                            },\n                            \"components\":\n                            {\n                                \"co\":203.61,\n                                \"no\":0.0,\n                                \"no2\":10.2,\n                                \"o3\":52.93,\n                                \"so2\":3.93,\n                                \"pm10\":4.96,\n                                \"nh3\":0.65\n                            },\n                            \"dt\":1625022000\n                        }\n                    ]\n                }\n        },\n        ...\n    ]\n}"
					}

					
				
			
		
			
				
					,
					

					"docs-desenvolvimento-testes": {
						"id": "docs-desenvolvimento-testes",
						"title": "Testes",
						"category": "",
						"url": " /docs/desenvolvimento/testes/",
						"content": "Esquema de Estratégia de Testes"
					}

					
				
			
		
			
				
					,
					

					"docs-frontend-manual": {
						"id": "docs-frontend-manual",
						"title": "Manual do Utilizador",
						"category": "",
						"url": " /docs/frontend/manual/",
						"content": "Destinada aos clientes do SkyView, a plataforma desenvolvida expõe alguns dos endpoints disponibilizados pela API, criando assim funcionalidades para os destinatários. Nesta, qualquer utilizador da mesma pode visualizar os voos que sobrevoam a Alemanha em tempo real, o índice de qualidade do ar nos aeroportos, entre outros.\n\nMaps\n\nNa página denominada “Maps”, é possível visualizar um mapa-múndi centrado na Alemanha. Em cima deste, existe um pequeno switch que permite ao utilizador escolher um dos dois modos de visualização possíveis nesta página, com as nomenclaturas “Environment’s Map” e “Flights’ Map” à sua esquerda e direita, respetivamente.\n\n\nExemplo da página Maps na plataforma.\n\nFlights’ Map\n\nPor omissão, o modo exibido será o dos voos, com o interruptor a ser preenchido por um tom de azul. Neste, o cliente pode acompanhar os aviões que sobrevoam a Alemanha em tempo real, com um pequeno ícone de um avião azulado a simbolizar cada voo. Ao longo do tempo, o ícone deslocar-se-á sobre o território alemão, replicando assim a trajetória do voo enquanto este estiver sobre o país.\n\n\nExemplo do mapa no modo “Flights’ Map.\n\nClicando com o botão do lado esquerdo do rato sobre qualquer avião apresentado no mapa, uma nova secção será exibida. Na parte superior desta, o código ICAO 24 correspondente ao avião selecionado será apresentado, bem como dois gráficos.\n\nSão estes os gráficos de velocidade (m/s) e de altitude (metros). Tal como o nome indica, o primeiro disponibiliza algumas das velocidades do avião registadas pela aplicação desde que teve conhecimento do mesmo. Ordenando estes valores cronologicamente, um gráfico fiel ao comportamento do avião é estabelecido. O mesmo se passa no segundo caso, registando as diferentes altitudes a que se encontrava o voo ao longo do tempo.\n\n\nExemplo do que é apresentado ao clicar num avião.\n\nEnvironment’s Map\n\nSe o utilizador clicar com o botão esquerdo do rato sobre o switch, este alterará o modo em exibição para a vista do ambiente. Esta mudança será acompanhada por uma troca de cor no switch de azul para um tom esverdeado. Os ícones representativos de cada voo serão removidos, dando lugar a outro conjunto de símbolos representando os aeroportos alemães.\n\n\nExemplo do mapa no modo “Environment’s Map.\n\nClicando com o botão do lado esquerdo do rato sobre qualquer ícone apresentado no mapa, uma nova secção será exibida. Nesta, é possível visualizar três parâmetros relativos ao aeroporto selecionado, sendo estes:\n\n\n  Airport\n  ICAO\n  Air Quality Index\n\n\nO primeiro item da lista, apresenta o nome do aeroporto em causa. Já o código aeroportuário ICAO, é utilizado para designar o aeroporto internacionalmente, fazendo parte de um acordo que conta com 180 países membros. O terceiro e último elemento, informa o cliente do índice de qualidade do ar, naquele momento, no aeródromo.\n\n\nExemplo do que é apresentado ao clicar num aeroporto.\n\nTable\n\nNa página denominada “Table”, é possível visualizar uma tabela denominada “Incoming Airplanes”. Esta tabela será preenchida pelos voos, com destino a um aeroporto alemão, prestes a aterrar.\n\nA tabela está então dividida em quatro colunas:\n\n\n  Icao24\n  Avião - Callsign\n  Aeroporto de chegada\n  Distância\n\n\nTal como referido na secção Flight’s Map, o código ICAO 24 representa o avião em si, sendo que o Callsign é também um identificador único, cujo prefixo corresponde ao seu país de origem. Os últimos dois campos são, tal como indicam, o nome do aeroporto alemão em que o avião está prestes a aterrar e a distância a que se encontra do mesmo.\n\n\nExemplo da página Table na plataforma."
					}

					
				
			
		
			
				
					,
					

					"docs-frontend-programador": {
						"id": "docs-frontend-programador",
						"title": "Perspetiva do Programador",
						"category": "",
						"url": " /docs/frontend/programador/",
						"content": "Nesta página será feito um resumo do trabalho efetuado na plataforma desenvolvida, bem como os objetivos iniciais que não foram atingidos a tempo.\n\nTal como é possível visualizar no gráfico referente à Arquitetura, esta web app resulta de um conjunto de páginas concebidas utilizando a framework Django.\n\nMaps\n\nNa página denominada “Maps”, vários tipos de mapas foram experimentados pela equipa, acabando por recorrer a um mapa disponibilizado pela ferramenta OpenStreetMap.\n\nFlights’ Map\n\nA lista de voos que sobrevoam a Alemanha em tempo real é obtida através do endpoint: /flights/stream. De notar que, devido ao vasto tráfego que geralmente sobrevoa a Alemanha, esta lista foi filtrada para apenas 20 voos, evitando assim spam visual e permitindo ao cliente aceder com mais facilidade a um determinado ícone. O código ICAO 24 bem como as coordenadas que permitem colocar o ícone sobre o mapa são então retiradas deste endpoint.\n\nOs aviões exibidos são colocados nas coordenadas recebidas, sendo que ao clicar sobre um dos ícones, um segundo endpoint é chamado: /flights/all?icao24=. Assim, é possível obter-se com maior detalhe informações sobre um voo em específico, sendo este filtrado pelo seu código ICAO 24. Aqui, a altitude geográfica, velocidade e *timestamp* associada a estes é obtida, providenciando assim todos os constituintes necessários para elaborar os gráficos que o cliente vê quando clica sobre o ícone.\n\nNeste modo de visualização, não foi possível realizar a tempo um efeito visual que replicasse a trajetória até então percorrida pelo avião.\n\nEnvironment’s Map\n\nOs dados referentes ao índice de qualidade do ar nos aeroportos alemães são obtidos através do endpoint: /environment/stream. O código ICAO do aeródromo, o seu nome, localização em coordenadas e índice de qualidade do ar são então retiradas deste endpoint.\n\nOs aeroportos exibidos são colocados nas coordenadas recebidas, sendo que ao clicar sobre um dos ícones, os restantes parâmetros tornam-se visíveis. Assim, é possível obter-se com maior detalhe informações sobre um aeroporto em específico quando o cliente clica com o botão do lado esquerdo sobre o ícone.\n\nNeste modo de visualização, não foi possível realizar a tempo um efeito visual que replicasse a trajetória até então percorrida pelo avião.\n\nTable\n\nNa página denominada “Table”, uma tabela foi constituída pela informação gerada no endpoint: /arrivals/stream. O código ICAO 24 do voo, o callsign do avião, o seu aeroporto de destino bem como a distância a que se encontra do mesmo são então retirados deste endpoint.\n\nNeste modo de visualização, por lapso da equipa, não foi adicionada a funcionalidade de interligar os campos da tabela com as visualizações nos mapas.\n\nOutros\n\nAlém das funcionalidades mencionadas acima, o grupo tinha como ambição a elaboração de uma página de estatísticas mais completa, para além dos gráficos já presentes. Era ainda uma das expectativas iniciais permitir ao utilizador subscrever uma panóplia de eventos, o que não se tornou possível."
					}

					
				
			
		
	};
</script>
<script src="/scripts/lunr.min.js"></script>
<script src="/scripts/search.js"></script>

			</article>
		</section>

		<script>
			document.getElementById("open-nav").addEventListener("click", function () {
				document.body.classList.toggle("nav-open");
			});
		</script>
	</body>
</html>
